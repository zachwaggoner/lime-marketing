<h1>Thread-safe Functions</h1>
<p>JavaScript functions can normally only be called from a native addon's main
thread. If an addon creates additional threads, then node-addon-api functions
that require a <code>Napi::Env</code>, <code>Napi::Value</code>, or <code>Napi::Reference</code> must not be
called from those threads.</p>
<p>When an addon has additional threads and JavaScript functions need to be invoked
based on the processing completed by those threads, those threads must
communicate with the addon's main thread so that the main thread can invoke the
JavaScript function on their behalf. The thread-safe function APIs provide an
easy way to do this. These APIs provide two types --
<a href="threadsafe_function.md"><code>Napi::ThreadSafeFunction</code></a> and
<a href="typed_threadsafe_function.md"><code>Napi::TypedThreadSafeFunction</code></a> -- as well as
APIs to create, destroy, and call objects of this type. The differences between
the two are subtle and are <a href="#implementation-differences">highlighted below</a>.
Regardless of which type you choose, the APIs between the two are similar.</p>
<p><code>Napi::[Typed]ThreadSafeFunction::New()</code> creates a persistent reference that
holds a JavaScript function which can be called from multiple threads. The calls
happen asynchronously. This means that values with which the JavaScript callback
is to be called will be placed in a queue, and, for each value in the queue, a
call will eventually be made to the JavaScript function.</p>
<p><code>Napi::[Typed]ThreadSafeFunction</code> objects are destroyed when every thread which
uses the object has called <code>Release()</code> or has received a return status of
<code>napi_closing</code> in response to a call to <code>BlockingCall()</code> or <code>NonBlockingCall()</code>.
The queue is emptied before the <code>Napi::[Typed]ThreadSafeFunction</code> is destroyed.
It is important that <code>Release()</code> be the last API call made in conjunction with a
given <code>Napi::[Typed]ThreadSafeFunction</code>, because after the call completes, there
is no guarantee that the <code>Napi::[Typed]ThreadSafeFunction</code> is still allocated.
For the same reason it is also important that no more use be made of a
thread-safe function after receiving a return value of <code>napi_closing</code> in
response to a call to <code>BlockingCall()</code> or <code>NonBlockingCall()</code>. Data associated
with the <code>Napi::[Typed]ThreadSafeFunction</code> can be freed in its <code>Finalizer</code>
callback which was passed to <code>[Typed]ThreadSafeFunction::New()</code>.</p>
<p>Once the number of threads making use of a <code>Napi::[Typed]ThreadSafeFunction</code>
reaches zero, no further threads can start making use of it by calling
<code>Acquire()</code>. In fact, all subsequent API calls associated with it, except
<code>Release()</code>, will return an error value of <code>napi_closing</code>.</p>
<h2>Implementation Differences</h2>
<p>The choice between <code>Napi::ThreadSafeFunction</code> and
<code>Napi::TypedThreadSafeFunction</code> depends largely on how you plan to execute your
native C++ code (the &quot;callback&quot;) on the Node.js thread.</p>
<h3><a href="threadsafe_function.md"><code>Napi::ThreadSafeFunction</code></a></h3>
<p>This API is designed without N-API 5 native support for <a href="https://github.com/nodejs/node/commit/53297e66cb">the optional JavaScript
function callback feature</a>.</p>
<p>This API has some dynamic functionality, in that:</p>
<ul>
<li>The <code>[Non]BlockingCall()</code> methods provide a <code>Napi::Function</code> parameter as the
callback to run when processing the data item on the main thread -- the
<code>CallJs</code> callback. Since the callback is a parameter, it can be changed for
every call.</li>
<li>Different C++ data types may be passed with each call of <code>[Non]BlockingCall()</code>
to match the specific data type as specified in the <code>CallJs</code> callback.</li>
</ul>
<p>Note that this functionality comes with some <strong>additional overhead</strong> and
situational <strong>memory leaks</strong>:</p>
<ul>
<li>The API acts as a &quot;broker&quot; between the underlying <code>napi_threadsafe_function</code>,
and dynamically constructs a wrapper for your callback on the heap for every
call to <code>[Non]BlockingCall()</code>.</li>
<li>In acting in this &quot;broker&quot; fashion, the API will call the underlying &quot;make
call&quot; N-API method on this packaged item. If the API has determined the
thread-safe function is no longer accessible (eg. all threads have released
yet there are still items on the queue), <strong>the callback passed to
[Non]BlockingCall will not execute</strong>. This means it is impossible to perform
clean-up for calls that never execute their <code>CallJs</code> callback. <strong>This may lead
to memory leaks</strong> if you are dynamically allocating memory.</li>
<li>The <code>CallJs</code> does not receive the thread-safe function's context as a
parameter. In order for the callback to access the context, it must have a
reference to either (1) the context directly, or (2) the thread-safe function
to call <code>GetContext()</code>. Furthermore, the <code>GetContext()</code> method is not
<em>type-safe</em>, as the method returns an object that can be &quot;any-casted&quot;, instead
of having a static type.</li>
</ul>
<h3><a href="typed_threadsafe_function.md"><code>Napi::TypedThreadSafeFunction</code></a></h3>
<p>The <code>TypedThreadSafeFunction</code> class is a new implementation to address the
drawbacks listed above. The API is designed with N-API 5's support of an
optional function callback. The API will correctly allow developers to pass
<code>std::nullptr</code> instead of a <code>const Function&amp;</code> for the callback function
specified in <code>::New</code>. It also provides helper APIs to <em>target</em> N-API 4 and
construct a no-op <code>Function</code> <strong>or</strong> to target N-API 5 and &quot;construct&quot; a
<code>std::nullptr</code> callback. This allows a single codebase to use the same APIs,
with just a switch of the <code>NAPI_VERSION</code> compile-time constant.</p>
<p>The removal of the dynamic call functionality has the following implications:</p>
<ul>
<li>The API does <em>not</em> act as a &quot;broker&quot; compared to the
<code>Napi::ThreadSafeFunction</code>. Once Node.js finalizes the thread-safe function,
the <code>CallJs</code> callback will execute with an empty <code>Napi::Env</code> for any remaining
items on the queue. This provides the ability to handle any necessary cleanup
of the item's data.</li>
<li>The callback <em>does</em> receive the context as a parameter, so a call to
<code>GetContext()</code> is <em>not</em> necessary. This context type is specified as the
<strong>first template argument</strong> specified to <code>::New</code>, ensuring type safety.</li>
<li>The <code>New()</code> constructor accepts the <code>CallJs</code> callback as the <strong>second type
argument</strong>. The callback must be statically defined for the API to access it.
This affords the ability to statically pass the context as the correct type
across all methods.</li>
<li>Only one C++ data type may be specified to every call to <code>[Non]BlockingCall()</code>
-- the <strong>third template argument</strong> specified to <code>::New</code>. Any &quot;dynamic call
data&quot; must be implemented by the user.</li>
</ul>
<h3>Usage Suggestions</h3>
<p>In summary, it may be best to use <code>Napi::TypedThreadSafeFunction</code> if:</p>
<ul>
<li>static, compile-time support for targeting N-API 4 or 5+ with an optional
JavaScript callback feature is desired;</li>
<li>the callback can have <code>static</code> storage class and will not change across calls
to <code>[Non]BlockingCall()</code>;</li>
<li>cleanup of items' data is required (eg. deleting dynamically-allocated data
that is created at the caller level).</li>
</ul>
<p>Otherwise, <code>Napi::ThreadSafeFunction</code> may be a better choice.</p>
