<h1>Class property and descriptor</h1>
<p>Property descriptor for use with <code>Napi::ObjectWrap::DefineClass()</code>.
This is different from the standalone <code>Napi::PropertyDescriptor</code> because it is
specific to each <code>Napi::ObjectWrap&lt;T&gt;</code> subclass.
This prevents using descriptors from a different class when defining a new class
(preventing the callbacks from having incorrect <code>this</code> pointers).</p>
<h2>Example</h2>
<pre><code class="language-cpp">#include &lt;napi.h&gt;

class Example : public Napi::ObjectWrap&lt;Example&gt; {
  public:
    static Napi::Object Init(Napi::Env env, Napi::Object exports);
    Example(const Napi::CallbackInfo &amp;info);

  private:
    static Napi::FunctionReference constructor;
    double _value;
    Napi::Value GetValue(const Napi::CallbackInfo &amp;info);
    void SetValue(const Napi::CallbackInfo &amp;info, const Napi::Value &amp;value);
};

Napi::Object Example::Init(Napi::Env env, Napi::Object exports) {
    Napi::Function func = DefineClass(env, &quot;Example&quot;, {
        // Register a class instance accessor with getter and setter functions.
        InstanceAccessor&lt;&amp;Example::GetValue, &amp;Example::SetValue&gt;(&quot;value&quot;),
        // We can also register a readonly accessor by omitting the setter.
        InstanceAccessor&lt;&amp;Example::GetValue&gt;(&quot;readOnlyProp&quot;)
    });

    constructor = Napi::Persistent(func);
    constructor.SuppressDestruct();
    exports.Set(&quot;Example&quot;, func);

    return exports;
}

Example::Example(const Napi::CallbackInfo &amp;info) : Napi::ObjectWrap&lt;Example&gt;(info) {
    Napi::Env env = info.Env();
    // ...
    Napi::Number value = info[0].As&lt;Napi::Number&gt;();
    this-&gt;_value = value.DoubleValue();
}

Napi::FunctionReference Example::constructor;

Napi::Value Example::GetValue(const Napi::CallbackInfo &amp;info) {
    Napi::Env env = info.Env();
    return Napi::Number::New(env, this-&gt;_value);
}

void Example::SetValue(const Napi::CallbackInfo &amp;info, const Napi::Value &amp;value) {
    Napi::Env env = info.Env();
    // ...
    Napi::Number arg = value.As&lt;Napi::Number&gt;();
    this-&gt;_value = arg.DoubleValue();
}

// Initialize native add-on
Napi::Object Init (Napi::Env env, Napi::Object exports) {
    Example::Init(env, exports);
    return exports;
}

// Register and initialize native add-on
NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)
</code></pre>
<p>The above code can be used from JavaScript as follows:</p>
<pre><code class="language-js">'use strict';

const { Example } = require('bindings')('addon');

const example = new Example(11);
console.log(example.value);
// It prints 11
example.value = 19;
console.log(example.value);
// It prints 19
example.readOnlyProp = 500;
console.log(example.readOnlyProp);
// Unchanged. It prints 19
</code></pre>
<h2>Methods</h2>
<h3>Constructor</h3>
<p>Creates new instance of <code>Napi::ClassPropertyDescriptor</code> descriptor object.</p>
<pre><code class="language-cpp">Napi::ClassPropertyDescriptor(napi_property_descriptor desc) : _desc(desc) {}
</code></pre>
<ul>
<li><code>[in] desc</code>: The <code>napi_property_descriptor</code></li>
</ul>
<p>Returns new instance of <code>Napi::ClassPropertyDescriptor</code> that is used as property descriptor
inside the <code>Napi::ObjectWrap&lt;T&gt;</code> class.</p>
<h3>Operator</h3>
<pre><code class="language-cpp">operator napi_property_descriptor&amp;() { return _desc; }
</code></pre>
<p>Returns the original N-API <code>napi_property_descriptor</code> wrapped inside the <code>Napi::ClassPropertyDescriptor</code></p>
<pre><code class="language-cpp">operator const napi_property_descriptor&amp;() const { return _desc; }
</code></pre>
<p>Returns the original N-API <code>napi_property_descriptor</code> wrapped inside the <code>Napi::ClassPropertyDescriptor</code></p>
