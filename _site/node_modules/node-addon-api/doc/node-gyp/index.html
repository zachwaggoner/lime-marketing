<h1>node-gyp</h1>
<p>C++ code needs to be compiled into executable form whether it be as an object
file to linked with others, a shared library, or a standalone executable.</p>
<p>The main reason for this is that we need to link to the Node.js dependencies and
headers correctly, another reason is that we need a cross platform way to build
C++ source into binary for the target platform.</p>
<p>Until now <strong>node-gyp</strong> is the <strong>de-facto</strong> standard build tool for writing
Node.js addons. It's based on Google's <strong>gyp</strong> build tool, which abstract away
many of the tedious issues related to cross platform building.</p>
<p><strong>node-gyp</strong> uses a file called <code>binding.gyp</code> that is located on the root of
your addon project.</p>
<p><code>binding.gyp</code> file, contains all building configurations organized with a
JSON like syntax. The most important parameter is the  <strong>target</strong> that must be
set to the same value used on the initialization code of the addon as in the
examples reported below:</p>
<h3><strong>binding.gyp</strong></h3>
<pre><code class="language-gyp">{
  &quot;targets&quot;: [
    {
      # myModule is the name of your native addon
      &quot;target_name&quot;: &quot;myModule&quot;,
      &quot;sources&quot;: [&quot;src/my_module.cc&quot;, ...],
      ...
  ]
}
</code></pre>
<h3><strong>my_module.cc</strong></h3>
<pre><code class="language-cpp">#include &lt;napi.h&gt;

// ...

/**
* This code is our entry-point. We receive two arguments here, the first is the
* environment that represent an independent instance of the JavaScript runtime,
* the second is exports, the same as module.exports in a .js file.
* You can either add properties to the exports object passed in or create your
* own exports object. In either case you must return the object to be used as
* the exports for the module when you return from the Init function.
*/
Napi::Object Init(Napi::Env env, Napi::Object exports) {

  // ...

  return exports;
}

/**
* This code defines the entry-point for the Node addon, it tells Node where to go
* once the library has been loaded into active memory. The first argument must
* match the &quot;target&quot; in our *binding.gyp*. Using NODE_GYP_MODULE_NAME ensures
* that the argument will be correct, as long as the module is built with
* node-gyp (which is the usual way of building modules). The second argument
* points to the function to invoke. The function must not be namespaced.
*/
NODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)
</code></pre>
<h2><strong>node-gyp</strong> reference</h2>
<ul>
<li><a href="https://www.npmjs.com/package/node-gyp#installation">Installation</a></li>
<li><a href="https://www.npmjs.com/package/node-gyp#how-to-use">How to use</a></li>
<li><a href="https://www.npmjs.com/package/node-gyp#the-bindinggyp-file">The binding.gyp file</a></li>
<li><a href="https://www.npmjs.com/package/node-gyp#commands">Commands</a></li>
<li><a href="https://www.npmjs.com/package/node-gyp#command-options">Command options</a></li>
<li><a href="https://www.npmjs.com/package/node-gyp#configuration">Configuration</a></li>
</ul>
<p>Sometimes finding the right settings for <code>binding.gyp</code> is not easy so to
accomplish at most complicated task please refer to:</p>
<ul>
<li><a href="https://gyp.gsrc.io/index.md">GYP documentation</a></li>
<li><a href="https://github.com/nodejs/node-gyp/wiki">node-gyp wiki</a></li>
</ul>
