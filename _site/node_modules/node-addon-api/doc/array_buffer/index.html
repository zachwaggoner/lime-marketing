<h1>ArrayBuffer</h1>
<p>Class <code>Napi::ArrayBuffer</code> inherits from class <a href="./object.md"><code>Napi::Object</code></a>.</p>
<p>The <code>Napi::ArrayBuffer</code> class corresponds to the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer">JavaScript <code>ArrayBuffer</code></a>
class.</p>
<h2>Methods</h2>
<h3>New</h3>
<p>Allocates a new <code>Napi::ArrayBuffer</code> instance with a given length.</p>
<pre><code class="language-cpp">static Napi::ArrayBuffer Napi::ArrayBuffer::New(napi_env env, size_t byteLength);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::ArrayBuffer</code> instance.</li>
<li><code>[in] byteLength</code>: The length to be allocated, in bytes.</li>
</ul>
<p>Returns a new <code>Napi::ArrayBuffer</code> instance.</p>
<h3>New</h3>
<p>Wraps the provided external data into a new <code>Napi::ArrayBuffer</code> instance.</p>
<p>The <code>Napi::ArrayBuffer</code> instance does not assume ownership for the data and
expects it to be valid for the lifetime of the instance. Since the
<code>Napi::ArrayBuffer</code> is subject to garbage collection this overload is only
suitable for data which is static and never needs to be freed.</p>
<pre><code class="language-cpp">static Napi::ArrayBuffer Napi::ArrayBuffer::New(napi_env env, void* externalData, size_t byteLength);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::ArrayBuffer</code> instance.</li>
<li><code>[in] externalData</code>: The pointer to the external data to wrap.</li>
<li><code>[in] byteLength</code>: The length of the <code>externalData</code>, in bytes.</li>
</ul>
<p>Returns a new <code>Napi::ArrayBuffer</code> instance.</p>
<h3>New</h3>
<p>Wraps the provided external data into a new <code>Napi::ArrayBuffer</code> instance.</p>
<p>The <code>Napi::ArrayBuffer</code> instance does not assume ownership for the data and
expects it to be valid for the lifetime of the instance. The data can only be
freed once the <code>finalizeCallback</code> is invoked to indicate that the
<code>Napi::ArrayBuffer</code> has been released.</p>
<pre><code class="language-cpp">template &lt;typename Finalizer&gt;
static Napi::ArrayBuffer Napi::ArrayBuffer::New(napi_env env,
                       void* externalData,
                       size_t byteLength,
                       Finalizer finalizeCallback);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::ArrayBuffer</code> instance.</li>
<li><code>[in] externalData</code>: The pointer to the external data to wrap.</li>
<li><code>[in] byteLength</code>: The length of the <code>externalData</code>, in bytes.</li>
<li><code>[in] finalizeCallback</code>: A function to be called when the <code>Napi::ArrayBuffer</code> is
destroyed. It must implement <code>operator()</code>, accept a <code>void*</code> (which is the
<code>externalData</code> pointer), and return <code>void</code>.</li>
</ul>
<p>Returns a new <code>Napi::ArrayBuffer</code> instance.</p>
<h3>New</h3>
<p>Wraps the provided external data into a new <code>Napi::ArrayBuffer</code> instance.</p>
<p>The <code>Napi::ArrayBuffer</code> instance does not assume ownership for the data and expects it
to be valid for the lifetime of the instance. The data can only be freed once
the <code>finalizeCallback</code> is invoked to indicate that the <code>Napi::ArrayBuffer</code> has been
released.</p>
<pre><code class="language-cpp">template &lt;typename Finalizer, typename Hint&gt;
static Napi::ArrayBuffer Napi::ArrayBuffer::New(napi_env env,
                       void* externalData,
                       size_t byteLength,
                       Finalizer finalizeCallback,
                       Hint* finalizeHint);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::ArrayBuffer</code> instance.</li>
<li><code>[in] externalData</code>: The pointer to the external data to wrap.</li>
<li><code>[in] byteLength</code>: The length of the <code>externalData</code>, in bytes.</li>
<li><code>[in] finalizeCallback</code>: The function to be called when the <code>Napi::ArrayBuffer</code> is
destroyed. It must implement <code>operator()</code>, accept a <code>void*</code> (which is the
<code>externalData</code> pointer) and <code>Hint*</code>, and return <code>void</code>.</li>
<li><code>[in] finalizeHint</code>: The hint to be passed as the second parameter of the
finalize callback.</li>
</ul>
<p>Returns a new <code>Napi::ArrayBuffer</code> instance.</p>
<h3>Constructor</h3>
<p>Initializes an empty instance of the <code>Napi::ArrayBuffer</code> class.</p>
<pre><code class="language-cpp">Napi::ArrayBuffer::ArrayBuffer();
</code></pre>
<h3>Constructor</h3>
<p>Initializes a wrapper instance of an existing <code>Napi::ArrayBuffer</code> object.</p>
<pre><code class="language-cpp">Napi::ArrayBuffer::ArrayBuffer(napi_env env, napi_value value);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment in which to create the <code>Napi::ArrayBuffer</code> instance.</li>
<li><code>[in] value</code>: The <code>Napi::ArrayBuffer</code> reference to wrap.</li>
</ul>
<h3>ByteLength</h3>
<pre><code class="language-cpp">size_t Napi::ArrayBuffer::ByteLength() const;
</code></pre>
<p>Returns the length of the wrapped data, in bytes.</p>
<h3>Data</h3>
<pre><code class="language-cpp">void* Napi::ArrayBuffer::Data() const;
</code></pre>
<p>Returns a pointer the wrapped data.</p>
<h3>Detach</h3>
<pre><code class="language-cpp">void Napi::ArrayBuffer::Detach();
</code></pre>
<p>Invokes the <code>ArrayBuffer</code> detach operation on a detachable <code>ArrayBuffer</code>.</p>
<h3>IsDetached</h3>
<pre><code class="language-cpp">bool Napi::ArrayBuffer::IsDetached() const;
</code></pre>
<p>Returns <code>true</code> if this <code>ArrayBuffer</code> has been detached.</p>
