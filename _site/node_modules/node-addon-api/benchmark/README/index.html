<h1>Benchmarks</h1>
<h2>Running the benchmarks</h2>
<p>From the parent directory, run</p>
<pre><code class="language-bash">npm run-script benchmark
</code></pre>
<p>The above script supports the following arguments:</p>
<ul>
<li><code>--benchmarks=...</code>: A semicolon-separated list of benchmark names. These names
will be mapped to file names in this directory by appending <code>.js</code>.</li>
</ul>
<h2>Adding benchmarks</h2>
<p>The steps below should be followed when adding new benchmarks.</p>
<ol start="0">
<li>
<p>Decide on a name for the benchmark. This name will be used in several places.
This example will use the name <code>new_benchmark</code>.</p>
</li>
<li>
<p>Create files <code>new_benchmark.cc</code> and <code>new_benchmark.js</code> in this directory.</p>
</li>
<li>
<p>Copy an existing benchmark in <code>binding.gyp</code> and change the target name prefix
and the source file name to <code>new_benchmark</code>. This should result in two new
targets which look like this:</p>
<pre><code class="language-gyp">  {
    'target_name': 'new_benchmark',
    'sources': [ 'new_benchmark.cc' ],
    'includes': [ '../except.gypi' ],
  },
  {
    'target_name': 'new_benchmark_noexcept',
    'sources': [ 'new_benchmark.cc' ],
    'includes': [ '../noexcept.gypi' ],
  },
</code></pre>
<p>There should always be a pair of targets: one bearing the name of the
benchmark and configured with C++ exceptions enabled, and one bearing the
same name followed by the suffix <code>_noexcept</code> and configured with C++
exceptions disabled. This will ensure that the benchmark can be written to
cover both the case where C++ exceptions are enabled and the case where they
are disabled.</p>
</li>
</ol>
