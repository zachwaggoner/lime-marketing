<h1>node-fetch</h1>
<p><a href="https://www.npmjs.com/package/node-fetch"><img src="https://flat.badgen.net/npm/v/node-fetch" alt="npm version"></a>
<a href="https://travis-ci.org/bitinn/node-fetch"><img src="https://flat.badgen.net/travis/bitinn/node-fetch" alt="build status"></a>
<a href="https://codecov.io/gh/bitinn/node-fetch"><img src="https://flat.badgen.net/codecov/c/github/bitinn/node-fetch/master" alt="coverage status"></a>
<a href="https://packagephobia.now.sh/result?p=node-fetch"><img src="https://flat.badgen.net/packagephobia/install/node-fetch" alt="install size"></a>
<a href="https://discord.gg/Zxbndcm"><img src="https://img.shields.io/discord/619915844268326952?color=%237289DA&amp;label=Discord&amp;style=flat-square" alt="Discord"></a></p>
<p>A light-weight module that brings <code>window.fetch</code> to Node.js</p>
<p>(We are looking for <a href="https://github.com/bitinn/node-fetch/issues/567">v2 maintainers and collaborators</a>)</p>
<p><a href="https://opencollective.com/node-fetch"><img src="https://opencollective.com/node-fetch/backers.svg" alt="Backers"></a></p>
<!-- TOC -->
<ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#difference-from-client-side-fetch">Difference from client-side fetch</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#loading-and-configuring-the-module">Loading and configuring the module</a></li>
<li><a href="#common-usage">Common Usage</a>
<ul>
<li><a href="#plain-text-or-html">Plain text or HTML</a></li>
<li><a href="#json">JSON</a></li>
<li><a href="#simple-post">Simple Post</a></li>
<li><a href="#post-with-json">Post with JSON</a></li>
<li><a href="#post-with-form-parameters">Post with form parameters</a></li>
<li><a href="#handling-exceptions">Handling exceptions</a></li>
<li><a href="#handling-client-and-server-errors">Handling client and server errors</a></li>
</ul>
</li>
<li><a href="#advanced-usage">Advanced Usage</a>
<ul>
<li><a href="#streams">Streams</a></li>
<li><a href="#buffer">Buffer</a></li>
<li><a href="#accessing-headers-and-other-meta-data">Accessing Headers and other Meta data</a></li>
<li><a href="#extract-set-cookie-header">Extract Set-Cookie Header</a></li>
<li><a href="#post-data-using-a-file-stream">Post data using a file stream</a></li>
<li><a href="#post-with-form-data-detect-multipart">Post with form-data (detect multipart)</a></li>
<li><a href="#request-cancellation-with-abortsignal">Request cancellation with AbortSignal</a></li>
</ul>
</li>
<li><a href="#api">API</a>
<ul>
<li><a href="#fetchurl-options">fetch(url[, options])</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#class-request">Class: Request</a></li>
<li><a href="#class-response">Class: Response</a></li>
<li><a href="#class-headers">Class: Headers</a></li>
<li><a href="#interface-body">Interface: Body</a></li>
<li><a href="#class-fetcherror">Class: FetchError</a></li>
</ul>
</li>
<li><a href="#license">License</a></li>
<li><a href="#acknowledgement">Acknowledgement</a></li>
</ul>
<!-- /TOC -->
<h2>Motivation</h2>
<p>Instead of implementing <code>XMLHttpRequest</code> in Node.js to run browser-specific <a href="https://github.com/github/fetch">Fetch polyfill</a>, why not go from native <code>http</code> to <code>fetch</code> API directly? Hence, <code>node-fetch</code>, minimal code for a <code>window.fetch</code> compatible API on Node.js runtime.</p>
<p>See Matt Andrews' <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> or Leonardo Quixada's <a href="https://github.com/lquixada/cross-fetch">cross-fetch</a> for isomorphic usage (exports <code>node-fetch</code> for server-side, <code>whatwg-fetch</code> for client-side).</p>
<h2>Features</h2>
<ul>
<li>Stay consistent with <code>window.fetch</code> API.</li>
<li>Make conscious trade-off when following <a href="https://fetch.spec.whatwg.org/">WHATWG fetch spec</a> and <a href="https://streams.spec.whatwg.org/">stream spec</a> implementation details, document known differences.</li>
<li>Use native promise but allow substituting it with [insert your favorite promise library].</li>
<li>Use native Node streams for body on both request and response.</li>
<li>Decode content encoding (gzip/deflate) properly and convert string output (such as <code>res.text()</code> and <code>res.json()</code>) to UTF-8 automatically.</li>
<li>Useful extensions such as timeout, redirect limit, response size limit, <a href="ERROR-HANDLING.md">explicit errors</a> for troubleshooting.</li>
</ul>
<h2>Difference from client-side fetch</h2>
<ul>
<li>See <a href="LIMITS.md">Known Differences</a> for details.</li>
<li>If you happen to use a missing feature that <code>window.fetch</code> offers, feel free to open an issue.</li>
<li>Pull requests are welcomed too!</li>
</ul>
<h2>Installation</h2>
<p>Current stable release (<code>2.x</code>)</p>
<pre><code class="language-sh">$ npm install node-fetch
</code></pre>
<h2>Loading and configuring the module</h2>
<p>We suggest you load the module via <code>require</code> until the stabilization of ES modules in node:</p>
<pre><code class="language-js">const fetch = require('node-fetch');
</code></pre>
<p>If you are using a Promise library other than native, set it through <code>fetch.Promise</code>:</p>
<pre><code class="language-js">const Bluebird = require('bluebird');

fetch.Promise = Bluebird;
</code></pre>
<h2>Common Usage</h2>
<p>NOTE: The documentation below is up-to-date with <code>2.x</code> releases; see the <a href="https://github.com/bitinn/node-fetch/blob/1.x/README.md"><code>1.x</code> readme</a>, <a href="https://github.com/bitinn/node-fetch/blob/1.x/CHANGELOG.md">changelog</a> and <a href="UPGRADE-GUIDE.md">2.x upgrade guide</a> for the differences.</p>
<h4>Plain text or HTML</h4>
<pre><code class="language-js">fetch('https://github.com/')
    .then(res =&gt; res.text())
    .then(body =&gt; console.log(body));
</code></pre>
<h4>JSON</h4>
<pre><code class="language-js">
fetch('https://api.github.com/users/github')
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Simple Post</h4>
<pre><code class="language-js">fetch('https://httpbin.org/post', { method: 'POST', body: 'a=1' })
    .then(res =&gt; res.json()) // expecting a json response
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Post with JSON</h4>
<pre><code class="language-js">const body = { a: 1 };

fetch('https://httpbin.org/post', {
        method: 'post',
        body:    JSON.stringify(body),
        headers: { 'Content-Type': 'application/json' },
    })
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Post with form parameters</h4>
<p><code>URLSearchParams</code> is available in Node.js as of v7.5.0. See <a href="https://nodejs.org/api/url.html#url_class_urlsearchparams">official documentation</a> for more usage methods.</p>
<p>NOTE: The <code>Content-Type</code> header is only set automatically to <code>x-www-form-urlencoded</code> when an instance of <code>URLSearchParams</code> is given as such:</p>
<pre><code class="language-js">const { URLSearchParams } = require('url');

const params = new URLSearchParams();
params.append('a', 1);

fetch('https://httpbin.org/post', { method: 'POST', body: params })
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Handling exceptions</h4>
<p>NOTE: 3xx-5xx responses are <em>NOT</em> exceptions and should be handled in <code>then()</code>; see the next section for more information.</p>
<p>Adding a catch to the fetch promise chain will catch <em>all</em> exceptions, such as errors originating from node core libraries, network errors and operational errors, which are instances of FetchError. See the <a href="ERROR-HANDLING.md">error handling document</a>  for more details.</p>
<pre><code class="language-js">fetch('https://domain.invalid/')
    .catch(err =&gt; console.error(err));
</code></pre>
<h4>Handling client and server errors</h4>
<p>It is common to create a helper function to check that the response contains no client (4xx) or server (5xx) error responses:</p>
<pre><code class="language-js">function checkStatus(res) {
    if (res.ok) { // res.status &gt;= 200 &amp;&amp; res.status &lt; 300
        return res;
    } else {
        throw MyCustomError(res.statusText);
    }
}

fetch('https://httpbin.org/status/400')
    .then(checkStatus)
    .then(res =&gt; console.log('will not get here...'))
</code></pre>
<h2>Advanced Usage</h2>
<h4>Streams</h4>
<p>The &quot;Node.js way&quot; is to use streams when possible:</p>
<pre><code class="language-js">fetch('https://assets-cdn.github.com/images/modules/logos_page/Octocat.png')
    .then(res =&gt; {
        const dest = fs.createWriteStream('./octocat.png');
        res.body.pipe(dest);
    });
</code></pre>
<h4>Buffer</h4>
<p>If you prefer to cache binary data in full, use buffer(). (NOTE: <code>buffer()</code> is a <code>node-fetch</code>-only API)</p>
<pre><code class="language-js">const fileType = require('file-type');

fetch('https://assets-cdn.github.com/images/modules/logos_page/Octocat.png')
    .then(res =&gt; res.buffer())
    .then(buffer =&gt; fileType(buffer))
    .then(type =&gt; { /* ... */ });
</code></pre>
<h4>Accessing Headers and other Meta data</h4>
<pre><code class="language-js">fetch('https://github.com/')
    .then(res =&gt; {
        console.log(res.ok);
        console.log(res.status);
        console.log(res.statusText);
        console.log(res.headers.raw());
        console.log(res.headers.get('content-type'));
    });
</code></pre>
<h4>Extract Set-Cookie Header</h4>
<p>Unlike browsers, you can access raw <code>Set-Cookie</code> headers manually using <code>Headers.raw()</code>. This is a <code>node-fetch</code> only API.</p>
<pre><code class="language-js">fetch(url).then(res =&gt; {
    // returns an array of values, instead of a string of comma-separated values
    console.log(res.headers.raw()['set-cookie']);
});
</code></pre>
<h4>Post data using a file stream</h4>
<pre><code class="language-js">const { createReadStream } = require('fs');

const stream = createReadStream('input.txt');

fetch('https://httpbin.org/post', { method: 'POST', body: stream })
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Post with form-data (detect multipart)</h4>
<pre><code class="language-js">const FormData = require('form-data');

const form = new FormData();
form.append('a', 1);

fetch('https://httpbin.org/post', { method: 'POST', body: form })
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));

// OR, using custom headers
// NOTE: getHeaders() is non-standard API

const form = new FormData();
form.append('a', 1);

const options = {
    method: 'POST',
    body: form,
    headers: form.getHeaders()
}

fetch('https://httpbin.org/post', options)
    .then(res =&gt; res.json())
    .then(json =&gt; console.log(json));
</code></pre>
<h4>Request cancellation with AbortSignal</h4>
<blockquote>
<p>NOTE: You may cancel streamed requests only on Node &gt;= v8.0.0</p>
</blockquote>
<p>You may cancel requests with <code>AbortController</code>. A suggested implementation is <a href="https://www.npmjs.com/package/abort-controller"><code>abort-controller</code></a>.</p>
<p>An example of timing out a request after 150ms could be achieved as the following:</p>
<pre><code class="language-js">import AbortController from 'abort-controller';

const controller = new AbortController();
const timeout = setTimeout(
  () =&gt; { controller.abort(); },
  150,
);

fetch(url, { signal: controller.signal })
  .then(res =&gt; res.json())
  .then(
    data =&gt; {
      useData(data)
    },
    err =&gt; {
      if (err.name === 'AbortError') {
        // request was aborted
      }
    },
  )
  .finally(() =&gt; {
    clearTimeout(timeout);
  });
</code></pre>
<p>See <a href="https://github.com/bitinn/node-fetch/blob/master/test/test.js">test cases</a> for more examples.</p>
<h2>API</h2>
<h3>fetch(url[, options])</h3>
<ul>
<li><code>url</code> A string representing the URL for fetching</li>
<li><code>options</code> <a href="#fetch-options">Options</a> for the HTTP(S) request</li>
<li>Returns: <code>Promise&lt;<a href="#class-response">Response</a>&gt;</code></li>
</ul>
<p>Perform an HTTP(S) fetch.</p>
<p><code>url</code> should be an absolute url, such as <code>https://example.com/</code>. A path-relative URL (<code>/file/under/root</code>) or protocol-relative URL (<code>//can-be-http-or-https.com/</code>) will result in a rejected <code>Promise</code>.</p>
<p><a id="fetch-options"></a></p>
<h3>Options</h3>
<p>The default values are shown after each option key.</p>
<pre><code class="language-js">{
    // These properties are part of the Fetch Standard
    method: 'GET',
    headers: {},        // request headers. format is the identical to that accepted by the Headers constructor (see below)
    body: null,         // request body. can be null, a string, a Buffer, a Blob, or a Node.js Readable stream
    redirect: 'follow', // set to `manual` to extract redirect headers, `error` to reject redirect
    signal: null,       // pass an instance of AbortSignal to optionally abort requests

    // The following properties are node-fetch extensions
    follow: 20,         // maximum redirect count. 0 to not follow redirect
    timeout: 0,         // req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies). Signal is recommended instead.
    compress: true,     // support gzip/deflate content encoding. false to disable
    size: 0,            // maximum response body size in bytes. 0 to disable
    agent: null         // http(s).Agent instance or function that returns an instance (see below)
}
</code></pre>
<h5>Default Headers</h5>
<p>If no values are set, the following request headers will be sent automatically:</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept-Encoding</code></td>
<td><code>gzip,deflate</code> <em>(when <code>options.compress === true</code>)</em></td>
</tr>
<tr>
<td><code>Accept</code></td>
<td><code>*/*</code></td>
</tr>
<tr>
<td><code>Connection</code></td>
<td><code>close</code> <em>(when no <code>options.agent</code> is present)</em></td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td><em>(automatically calculated, if possible)</em></td>
</tr>
<tr>
<td><code>Transfer-Encoding</code></td>
<td><code>chunked</code> <em>(when <code>req.body</code> is a stream)</em></td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td><code>node-fetch/1.0 (+https://github.com/bitinn/node-fetch)</code></td>
</tr>
</tbody>
</table>
<p>Note: when <code>body</code> is a <code>Stream</code>, <code>Content-Length</code> is not set automatically.</p>
<h5>Custom Agent</h5>
<p>The <code>agent</code> option allows you to specify networking related options which are out of the scope of Fetch, including and not limited to the following:</p>
<ul>
<li>Support self-signed certificate</li>
<li>Use only IPv4 or IPv6</li>
<li>Custom DNS Lookup</li>
</ul>
<p>See <a href="https://nodejs.org/api/http.html#http_new_agent_options"><code>http.Agent</code></a> for more information.</p>
<p>In addition, the <code>agent</code> option accepts a function that returns <code>http</code>(s)<code>.Agent</code> instance given current <a href="https://nodejs.org/api/url.html">URL</a>, this is useful during a redirection chain across HTTP and HTTPS protocol.</p>
<pre><code class="language-js">const httpAgent = new http.Agent({
    keepAlive: true
});
const httpsAgent = new https.Agent({
    keepAlive: true
});

const options = {
    agent: function (_parsedURL) {
        if (_parsedURL.protocol == 'http:') {
            return httpAgent;
        } else {
            return httpsAgent;
        }
    }
}
</code></pre>
<p><a id="class-request"></a></p>
<h3>Class: Request</h3>
<p>An HTTP(S) request containing information about URL, method, headers, and the body. This class implements the <a href="#iface-body">Body</a> interface.</p>
<p>Due to the nature of Node.js, the following properties are not implemented at this moment:</p>
<ul>
<li><code>type</code></li>
<li><code>destination</code></li>
<li><code>referrer</code></li>
<li><code>referrerPolicy</code></li>
<li><code>mode</code></li>
<li><code>credentials</code></li>
<li><code>cache</code></li>
<li><code>integrity</code></li>
<li><code>keepalive</code></li>
</ul>
<p>The following node-fetch extension properties are provided:</p>
<ul>
<li><code>follow</code></li>
<li><code>compress</code></li>
<li><code>counter</code></li>
<li><code>agent</code></li>
</ul>
<p>See <a href="#fetch-options">options</a> for exact meaning of these extensions.</p>
<h4>new Request(input[, options])</h4>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>input</code> A string representing a URL, or another <code>Request</code> (which will be cloned)</li>
<li><code>options</code> [Options][#fetch-options] for the HTTP(S) request</li>
</ul>
<p>Constructs a new <code>Request</code> object. The constructor is identical to that in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request">browser</a>.</p>
<p>In most cases, directly <code>fetch(url, options)</code> is simpler than creating a <code>Request</code> object.</p>
<p><a id="class-response"></a></p>
<h3>Class: Response</h3>
<p>An HTTP(S) response. This class implements the <a href="#iface-body">Body</a> interface.</p>
<p>The following properties are not implemented in node-fetch at this moment:</p>
<ul>
<li><code>Response.error()</code></li>
<li><code>Response.redirect()</code></li>
<li><code>type</code></li>
<li><code>trailer</code></li>
</ul>
<h4>new Response([body[, options]])</h4>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>body</code> A <code>String</code> or <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>Readable</code> stream</a></li>
<li><code>options</code> A <a href="https://fetch.spec.whatwg.org/#responseinit"><code>ResponseInit</code></a> options dictionary</li>
</ul>
<p>Constructs a new <code>Response</code> object. The constructor is identical to that in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/Response">browser</a>.</p>
<p>Because Node.js does not implement service workers (for which this class was designed), one rarely has to construct a <code>Response</code> directly.</p>
<h4>response.ok</h4>
<p><small><em>(spec-compliant)</em></small></p>
<p>Convenience property representing if the request ended normally. Will evaluate to true if the response status was greater than or equal to 200 but smaller than 300.</p>
<h4>response.redirected</h4>
<p><small><em>(spec-compliant)</em></small></p>
<p>Convenience property representing if the request has been redirected at least once. Will evaluate to true if the internal redirect counter is greater than 0.</p>
<p><a id="class-headers"></a></p>
<h3>Class: Headers</h3>
<p>This class allows manipulating and iterating over a set of HTTP headers. All methods specified in the <a href="https://fetch.spec.whatwg.org/">Fetch Standard</a> are implemented.</p>
<h4>new Headers([init])</h4>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>init</code> Optional argument to pre-fill the <code>Headers</code> object</li>
</ul>
<p>Construct a new <code>Headers</code> object. <code>init</code> can be either <code>null</code>, a <code>Headers</code> object, an key-value map object or any iterable object.</p>
<pre><code class="language-js">// Example adapted from https://fetch.spec.whatwg.org/#example-headers-class

const meta = {
  'Content-Type': 'text/xml',
  'Breaking-Bad': '&lt;3'
};
const headers = new Headers(meta);

// The above is equivalent to
const meta = [
  [ 'Content-Type', 'text/xml' ],
  [ 'Breaking-Bad', '&lt;3' ]
];
const headers = new Headers(meta);

// You can in fact use any iterable objects, like a Map or even another Headers
const meta = new Map();
meta.set('Content-Type', 'text/xml');
meta.set('Breaking-Bad', '&lt;3');
const headers = new Headers(meta);
const copyOfHeaders = new Headers(headers);
</code></pre>
<p><a id="iface-body"></a></p>
<h3>Interface: Body</h3>
<p><code>Body</code> is an abstract interface with methods that are applicable to both <code>Request</code> and <code>Response</code> classes.</p>
<p>The following methods are not yet implemented in node-fetch at this moment:</p>
<ul>
<li><code>formData()</code></li>
</ul>
<h4>body.body</h4>
<p><small><em>(deviation from spec)</em></small></p>
<ul>
<li>Node.js <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>Readable</code> stream</a></li>
</ul>
<p>Data are encapsulated in the <code>Body</code> object. Note that while the <a href="https://fetch.spec.whatwg.org/">Fetch Standard</a> requires the property to always be a WHATWG <code>ReadableStream</code>, in node-fetch it is a Node.js <a href="https://nodejs.org/api/stream.html#stream_readable_streams"><code>Readable</code> stream</a>.</p>
<h4>body.bodyUsed</h4>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li><code>Boolean</code></li>
</ul>
<p>A boolean property for if this body has been consumed. Per the specs, a consumed body cannot be used again.</p>
<h4>body.arrayBuffer()</h4>
<h4>body.blob()</h4>
<h4>body.json()</h4>
<h4>body.text()</h4>
<p><small><em>(spec-compliant)</em></small></p>
<ul>
<li>Returns: <code>Promise</code></li>
</ul>
<p>Consume the body and return a promise that will resolve to one of these formats.</p>
<h4>body.buffer()</h4>
<p><small><em>(node-fetch extension)</em></small></p>
<ul>
<li>Returns: <code>Promise&lt;Buffer&gt;</code></li>
</ul>
<p>Consume the body and return a promise that will resolve to a Buffer.</p>
<h4>body.textConverted()</h4>
<p><small><em>(node-fetch extension)</em></small></p>
<ul>
<li>Returns: <code>Promise&lt;String&gt;</code></li>
</ul>
<p>Identical to <code>body.text()</code>, except instead of always converting to UTF-8, encoding sniffing will be performed and text converted to UTF-8 if possible.</p>
<p>(This API requires an optional dependency of the npm package <a href="https://www.npmjs.com/package/encoding">encoding</a>, which you need to install manually. <code>webpack</code> users may see <a href="https://github.com/bitinn/node-fetch/issues/412#issuecomment-379007792">a warning message</a> due to this optional dependency.)</p>
<p><a id="class-fetcherror"></a></p>
<h3>Class: FetchError</h3>
<p><small><em>(node-fetch extension)</em></small></p>
<p>An operational error in the fetching process. See <a href="https://github.com/bitinn/node-fetch/blob/master/ERROR-HANDLING.md">ERROR-HANDLING.md</a> for more info.</p>
<p><a id="class-aborterror"></a></p>
<h3>Class: AbortError</h3>
<p><small><em>(node-fetch extension)</em></small></p>
<p>An Error thrown when the request is aborted in response to an <code>AbortSignal</code>'s <code>abort</code> event. It has a <code>name</code> property of <code>AbortError</code>. See <a href="https://github.com/bitinn/node-fetch/blob/master/ERROR-HANDLING.md">ERROR-HANDLING.MD</a> for more info.</p>
<h2>Acknowledgement</h2>
<p>Thanks to <a href="https://github.com/github/fetch">github/fetch</a> for providing a solid implementation reference.</p>
<p><code>node-fetch</code> v1 was maintained by <a href="https://github.com/bitinn">@bitinn</a>; v2 was maintained by <a href="https://github.com/timothygu">@TimothyGu</a>, <a href="https://github.com/bitinn">@bitinn</a> and <a href="https://github.com/jimmywarting">@jimmywarting</a>; v2 readme is written by <a href="https://github.com/jkantr">@jkantr</a>.</p>
<h2>License</h2>
<p>MIT</p>
