<h1>tar-fs</h1>
<p>filesystem bindings for <a href="https://github.com/mafintosh/tar-stream">tar-stream</a>.</p>
<pre><code>npm install tar-fs
</code></pre>
<p><a href="http://travis-ci.org/mafintosh/tar-fs"><img src="https://secure.travis-ci.org/mafintosh/tar-fs.png" alt="build status"></a></p>
<h2>Usage</h2>
<p>tar-fs allows you to pack directories into tarballs and extract tarballs into directories.</p>
<p>It doesn't gunzip for you, so if you want to extract a <code>.tar.gz</code> with this you'll need to use something like <a href="https://github.com/mafintosh/gunzip-maybe">gunzip-maybe</a> in addition to this.</p>
<pre><code class="language-js">var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
</code></pre>
<p>To ignore various files when packing or extracting add a ignore function to the options. <code>ignore</code>
is also an alias for <code>filter</code>. Additionally you get <code>header</code> if you use ignore while extracting.
That way you could also filter by metadata.</p>
<pre><code class="language-js">var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files &amp; directories, ignore e.g. symlinks
    return header.type !== 'file' &amp;&amp; header.type !== 'directory'
  }
})
</code></pre>
<p>You can also specify which entries to pack using the <code>entries</code> option</p>
<pre><code class="language-js">var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
</code></pre>
<p>If you want to modify the headers when packing/extracting add a map function to the options</p>
<pre><code class="language-js">var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
</code></pre>
<p>Similarly you can use <code>mapStream</code> incase you wanna modify the input/output file streams</p>
<pre><code class="language-js">var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
</code></pre>
<p>Set <code>options.fmode</code> and <code>options.dmode</code> to ensure that files/directories extracted have the corresponding modes</p>
<pre><code class="language-js">var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
</code></pre>
<p>It can be useful to use <code>dmode</code> and <code>fmode</code> if you are packing/unpacking tarballs between *nix/windows to ensure that all files/directories unpacked are readable.</p>
<p>Alternatively you can set <code>options.readable</code> and/or <code>options.writable</code> to set the dmode and fmode to readable/writable.</p>
<pre><code class="language-js">var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
</code></pre>
<p>Set <code>options.strict</code> to <code>false</code> if you want to ignore errors due to unsupported entry types (like device files)</p>
<p>To dereference symlinks (pack the contents of the symlink instead of the link itself) set <code>options.dereference</code> to <code>true</code>.</p>
<h2>Copy a directory</h2>
<p>Copying a directory with permissions and mtime intact is as simple as</p>
<pre><code class="language-js">tar.pack('source-directory').pipe(tar.extract('dest-directory'))
</code></pre>
<h2>Interaction with <a href="https://github.com/mafintosh/tar-stream"><code>tar-stream</code></a></h2>
<p>Use <code>finalize: false</code> and the <code>finish</code> hook to
leave the pack stream open for further entries (see
<a href="https://github.com/mafintosh/tar-stream#packing"><code>tar-stream#pack</code></a>),
and use <code>pack</code> to pass an existing pack stream.</p>
<pre><code class="language-js">var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, &quot;hello&quot;)
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
</code></pre>
<h2>Performance</h2>
<p>Packing and extracting a 6.1 GB with 2496 directories and 2398 files yields the following results on my Macbook Air.
<a href="https://gist.github.com/mafintosh/8102201">See the benchmark here</a></p>
<ul>
<li>tar-fs: 34.261 seconds</li>
<li><a href="https://github.com/isaacs/node-tar">node-tar</a>: 366.123 seconds (or 10x slower)</li>
</ul>
<h2>License</h2>
<p>MIT</p>
