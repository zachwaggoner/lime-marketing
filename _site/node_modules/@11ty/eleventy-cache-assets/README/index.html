<h1>eleventy-cache-assets</h1>
<p>Don’t do a network request to your data source on every build! Do it once every minute, or every hour, or every day!</p>
<p>This can save any kind of asset—JSON, HTML, images, videos, etc.</p>
<ul>
<li>
<p>Requires <strong>Node 10+</strong></p>
</li>
<li>
<p>Fetch a remote URL and saves it to a local cache.</p>
</li>
<li>
<p>Control concurrency so we don’t make too many network requests at the same time.</p>
</li>
<li>
<p>If cache expires and the network connection fails, it will still use the cached request.</p>
</li>
</ul>
<h2>Installation</h2>
<pre><code>npm install @11ty/eleventy-cache-assets
</code></pre>
<h3>Important Security and Privacy Notice</h3>
<p>This plugin caches complete network responses. Unless you’re willing to perform a full review of everything this plugin caches to disk for privacy and security exposure, it is <em>strongly</em> recommended that you add the <code>.cache</code> folder to your <code>.gitignore</code> file so that it doesn’t get checked in to your git repository.</p>
<p>Are you 100% sure that private e-mail addresses aren’t being returned from a cached API? I’m guessing no—just add <code>.cache</code> to your <code>.gitignore</code>. Right now. Do it.</p>
<h2>Usage</h2>
<h3>Cache a JSON file from an API</h3>
<pre><code class="language-js">let url = &quot;https://api.github.com/repos/11ty/eleventy&quot;;
let json = await CacheAsset(url, {
	duration: &quot;1d&quot;,
	type: &quot;json&quot;
});
</code></pre>
<h3>Options</h3>
<h4>Change the Cache Duration</h4>
<p>The <code>duration</code> option currently supports the following shorthand values:</p>
<ul>
<li><code>s</code> is seconds (e.g. <code>duration: &quot;43s&quot;</code>)</li>
<li><code>m</code> is minutes (e.g. <code>duration: &quot;2m&quot;</code>)</li>
<li><code>h</code> is hours (e.g. <code>duration: &quot;99h&quot;</code>)</li>
<li><code>d</code> is days</li>
<li><code>w</code> is weeks (7 days)</li>
<li><code>y</code> is 365 days (about 1 year)</li>
</ul>
<h4>Type</h4>
<ul>
<li><code>type: &quot;json&quot;</code></li>
<li><code>type: &quot;text&quot;</code></li>
<li><code>type: &quot;buffer&quot;</code> (default: use this for non-text things)</li>
</ul>
<h4>Cache Directory</h4>
<p>The <code>directory</code> option let’s you change where the cache is stored. It is strongly recommended that you add this folder to your <code>.gitignore</code> file (per the Security and Privacy Notice above).</p>
<pre><code class="language-js">let json = await CacheAsset(&quot;https://…&quot;, {
	directory: &quot;.cache&quot;
});
</code></pre>
<h3>Handle failure gracefully</h3>
<p>Note that this will only apply if the first request fails (and no cache exists). If a failure happens and a cached entry already exists (even if it’s expired), it will use the cached entry.</p>
<pre><code class="language-js">async function fetchData() {
	try {
		let url = &quot;https://api.github.com/repos/11ty/eleventy&quot;;
		/* promise */
		return CacheAsset(url, {
			duration: &quot;1d&quot;,
			type: &quot;json&quot;
		});
	} catch(e) {
		return {
			// my failure fallback data
		}
	}
}
</code></pre>
<h3>Cache a Remote Image</h3>
<p>This is what <a href="https://github.com/11ty/eleventy-img/"><code>eleventy-img</code></a> uses internally.</p>
<pre><code class="language-js">const CacheAsset = require(&quot;@11ty/eleventy-cache-assets&quot;);
let url = &quot;https://www.zachleat.com/img/avatar-2017-big.png&quot;;
let imageBuffer = await CacheAsset(url, {
	duration: &quot;1d&quot;,
	type: &quot;buffer&quot;
});
// Use imageBuffer as an input to the `sharp` plugin, for example
</code></pre>
<h3>Remove query params from cache identifier</h3>
<p>(Version 2.0.3 and newer) If your fetched URL contains some query parameters that aren’t relevant to the identifier used in the cache, remove them using the <code>removeUrlQueryParams</code> option.</p>
<pre><code class="language-js">const CacheAsset = require(&quot;@11ty/eleventy-cache-assets&quot;);
let url = &quot;https://www.zachleat.com/img/avatar-2017-big.png?Get=rid&amp;of=these&quot;;
let imageBuffer = await CacheAsset(url, {
	removeUrlQueryParams: true
});
</code></pre>
<h3>Fetch Google Fonts CSS</h3>
<p>Also a good example of using <code>fetchOptions</code> to pass in a custom user agent. Full option list is available on the <a href="https://www.npmjs.com/package/node-fetch#options"><code>node-fetch</code> documentation</a>.</p>
<pre><code class="language-js">const CacheAsset = require(&quot;@11ty/eleventy-cache-assets&quot;);
let url = &quot;https://fonts.googleapis.com/css?family=Roboto+Mono:400&amp;display=swap&quot;;
let fontCss = await CacheAsset(url, {
	duration: &quot;1d&quot;,
	type: &quot;text&quot;,
	fetchOptions: {
		headers: {
			// lol
			&quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot;
		}
	}
});
</code></pre>
<h3>Change Global Plugin Concurrency</h3>
<pre><code class="language-js">const CacheAsset = require(&quot;@11ty/eleventy-cache-assets&quot;);
CacheAsset.concurrency = 4; // default is 10
</code></pre>
<h3>Command line debug output</h3>
<pre><code class="language-js">DEBUG=EleventyCacheAssets* node your-node-script.js
DEBUG=EleventyCacheAssets* npx @11ty/eleventy
</code></pre>
<!--
## Roadmap

* Add support for tiered asset requests, e.g. CSS requests background-images and web fonts, for example.

## Open Questions

* `flat-cache` save method seems to be synchronous, is there a better async one?
* Our cache stores raw buffers internally, which are pretty bloated compared to the original. Surely there is a more efficient way to do this. Maybe store the files in their original format.
-->
