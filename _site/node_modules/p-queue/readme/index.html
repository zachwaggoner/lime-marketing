<h1>p-queue <a href="https://travis-ci.com/github/sindresorhus/p-queue"><img src="https://travis-ci.com/sindresorhus/p-queue.svg?branch=master" alt="Build Status"></a> <a href="https://codecov.io/gh/sindresorhus/p-queue"><img src="https://codecov.io/gh/sindresorhus/p-queue/branch/master/graph/badge.svg" alt="codecov"></a></h1>
<blockquote>
<p>Promise queue with concurrency control</p>
</blockquote>
<p>Useful for rate-limiting async (or sync) operations. For example, when interacting with a REST API or when doing CPU/memory intensive tasks.</p>
<h2>Install</h2>
<pre><code>$ npm install p-queue
</code></pre>
<h2>Usage</h2>
<p>Here we run only one promise at the time. For example, set <code>concurrency</code> to 4 to run four promises at the same time.</p>
<pre><code class="language-js">const {default: PQueue} = require('p-queue');
const got = require('got');

const queue = new PQueue({concurrency: 1});

(async () =&gt; {
	await queue.add(() =&gt; got('https://sindresorhus.com'));
	console.log('Done: sindresorhus.com');
})();

(async () =&gt; {
	await queue.add(() =&gt; got('https://avajs.dev'));
	console.log('Done: avajs.dev');
})();

(async () =&gt; {
	const task = await getUnicornTask();
	await queue.add(task);
	console.log('Done: Unicorn task');
})();
</code></pre>
<h2>API</h2>
<h3>PQueue(options?)</h3>
<p>Returns a new <code>queue</code> instance, which is an <a href="https://github.com/primus/eventemitter3"><code>EventEmitter3</code></a> subclass.</p>
<h4>options</h4>
<p>Type: <code>object</code></p>
<h5>concurrency</h5>
<p>Type: <code>number</code><br>
Default: <code>Infinity</code><br>
Minimum: <code>1</code></p>
<p>Concurrency limit.</p>
<h5>timeout</h5>
<p>Type: <code>number</code></p>
<p>Per-operation timeout in milliseconds. Operations fulfill once <code>timeout</code> elapses if they haven't already.</p>
<h5>throwOnTimeout</h5>
<p>Type: <code>boolean</code><br>
Default: <code>false</code></p>
<p>Whether or not a timeout is considered an exception.</p>
<h5>autoStart</h5>
<p>Type: <code>boolean</code><br>
Default: <code>true</code></p>
<p>Whether queue tasks within concurrency limit, are auto-executed as soon as they're added.</p>
<h5>queueClass</h5>
<p>Type: <code>Function</code></p>
<p>Class with a <code>enqueue</code> and <code>dequeue</code> method, and a <code>size</code> getter. See the <a href="#custom-queueclass">Custom QueueClass</a> section.</p>
<h5>intervalCap</h5>
<p>Type: <code>number</code><br>
Default: <code>Infinity</code><br>
Minimum: <code>1</code></p>
<p>The max number of runs in the given interval of time.</p>
<h5>interval</h5>
<p>Type: <code>number</code><br>
Default: <code>0</code><br>
Minimum: <code>0</code></p>
<p>The length of time in milliseconds before the interval count resets. Must be finite.</p>
<h5>carryoverConcurrencyCount</h5>
<p>Type: <code>boolean</code><br>
Default: <code>false</code></p>
<p>If <code>true</code>, specifies that any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">pending</a> Promises, should be carried over into the next interval and counted against the <code>intervalCap</code>. If <code>false</code>, any of those pending Promises will not count towards the next <code>intervalCap</code>.</p>
<h3>queue</h3>
<p><code>PQueue</code> instance.</p>
<h4>.add(fn, options?)</h4>
<p>Adds a sync or async task to the queue. Always returns a promise.</p>
<h5>fn</h5>
<p>Type: <code>Function</code></p>
<p>Promise-returning/async function.</p>
<h4>options</h4>
<p>Type: <code>object</code></p>
<h5>priority</h5>
<p>Type: <code>number</code><br>
Default: <code>0</code></p>
<p>Priority of operation. Operations with greater priority will be scheduled first.</p>
<h4>.addAll(fns, options?)</h4>
<p>Same as <code>.add()</code>, but accepts an array of sync or async functions and returns a promise that resolves when all functions are resolved.</p>
<h4>.pause()</h4>
<p>Put queue execution on hold.</p>
<h4>.start()</h4>
<p>Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via <code>options.autoStart = false</code> or by <code>.pause()</code> method.)</p>
<p>Returns <code>this</code> (the instance).</p>
<h4>.onEmpty()</h4>
<p>Returns a promise that settles when the queue becomes empty.</p>
<p>Can be called multiple times. Useful if you for example add additional items at a later time.</p>
<h4>.onIdle()</h4>
<p>Returns a promise that settles when the queue becomes empty, and all promises have completed; <code>queue.size === 0 &amp;&amp; queue.pending === 0</code>.</p>
<p>The difference with <code>.onEmpty</code> is that <code>.onIdle</code> guarantees that all work from the queue has finished. <code>.onEmpty</code> merely signals that the queue is empty, but it could mean that some promises haven't completed yet.</p>
<h4>.clear()</h4>
<p>Clear the queue.</p>
<h4>.size</h4>
<p>Size of the queue.</p>
<h4>.sizeBy(options)</h4>
<p>Size of the queue, filtered by the given options.</p>
<p>For example, this can be used to find the number of items remaining in the queue with a specific priority level.</p>
<pre><code class="language-js">const queue = new PQueue();

queue.add(async () =&gt; 'ü¶Ñ', {priority: 1});
queue.add(async () =&gt; 'ü¶Ñ', {priority: 0});
queue.add(async () =&gt; 'ü¶Ñ', {priority: 1});

console.log(queue.sizeBy({priority: 1}));
//=&gt; 2

console.log(queue.sizeBy({priority: 0}));
//=&gt; 1
</code></pre>
<h4>.pending</h4>
<p>Number of pending promises.</p>
<h4><a href="#timeout">.timeout</a></h4>
<h4><a href="#concurrency">.concurrency</a></h4>
<h4>.isPaused</h4>
<p>Whether the queue is currently paused.</p>
<h2>Events</h2>
<h4>active</h4>
<p>Emitted as each item is processed in the queue for the purpose of tracking progress.</p>
<pre><code class="language-js">const delay = require('delay');
const {default: PQueue} = require('p-queue');

const queue = new PQueue({concurrency: 2});

let count = 0;
queue.on('active', () =&gt; {
	console.log(`Working on item #${++count}.  Size: ${queue.size}  Pending: ${queue.pending}`);
});

queue.add(() =&gt; Promise.resolve());
queue.add(() =&gt; delay(2000));
queue.add(() =&gt; Promise.resolve());
queue.add(() =&gt; Promise.resolve());
queue.add(() =&gt; delay(500));
</code></pre>
<h4>idle</h4>
<p>Emitted every time the queue becomes empty and all promises have completed; <code>queue.size === 0 &amp;&amp; queue.pending === 0</code>.</p>
<pre><code class="language-js">const delay = require('delay');
const {default: PQueue} = require('p-queue');

const queue = new PQueue();

queue.on('idle', () =&gt; {
	console.log(`Queue is idle.  Size: ${queue.size}  Pending: ${queue.pending}`);
});

const job1 = queue.add(() =&gt; delay(2000));
const job2 = queue.add(() =&gt; delay(500));

await job1;
await job2;
// =&gt; 'Queue is idle.  Size: 0  Pending: 0'

await queue.add(() =&gt; delay(600));
// =&gt; 'Queue is idle.  Size: 0  Pending: 0'
</code></pre>
<p>The <code>idle</code> event is emitted every time the queue reaches an idle state. On the other hand, the promise the <code>onIdle()</code> function returns resolves once the queue becomes idle instead of every time the queue is idle.</p>
<h4>add</h4>
<p>Emitted every time the add method is called and the number of pending or queued tasks is increased.</p>
<h4>next</h4>
<p>Emitted every time a task is completed and the number of pending or queued tasks is decreased.</p>
<pre><code class="language-js">const delay = require('delay');
const {default: PQueue} = require('p-queue');

const queue = new PQueue();

queue.on('add', () =&gt; {
	console.log(`Task is added.  Size: ${queue.size}  Pending: ${queue.pending}`);
});
queue.on('next', () =&gt; {
	console.log(`Task is completed.  Size: ${queue.size}  Pending: ${queue.pending}`);
});

const job1 = queue.add(() =&gt; delay(2000));
const job2 = queue.add(() =&gt; delay(500));

await job1;
await job2;
//=&gt; 'Task is added.  Size: 0  Pending: 1'
//=&gt; 'Task is added.  Size: 0  Pending: 2'

await queue.add(() =&gt; delay(600));
//=&gt; 'Task is completed.  Size: 0  Pending: 1'
//=&gt; 'Task is completed.  Size: 0  Pending: 0'
</code></pre>
<h2>Advanced example</h2>
<p>A more advanced example to help you understand the flow.</p>
<pre><code class="language-js">const delay = require('delay');
const {default: PQueue} = require('p-queue');

const queue = new PQueue({concurrency: 1});

(async () =&gt; {
	await delay(200);

	console.log(`8. Pending promises: ${queue.pending}`);
	//=&gt; '8. Pending promises: 0'

	(async () =&gt; {
		await queue.add(async () =&gt; 'üêô');
		console.log('11. Resolved')
	})();

	console.log('9. Added üêô');

	console.log(`10. Pending promises: ${queue.pending}`);
	//=&gt; '10. Pending promises: 1'

	await queue.onIdle();
	console.log('12. All work is done');
})();

(async () =&gt; {
	await queue.add(async () =&gt; 'ü¶Ñ');
	console.log('5. Resolved')
})();
console.log('1. Added ü¶Ñ');

(async () =&gt; {
	await queue.add(async () =&gt; 'üê¥');
	console.log('6. Resolved')
})();
console.log('2. Added üê¥');

(async () =&gt; {
	await queue.onEmpty();
	console.log('7. Queue is empty');
})();

console.log(`3. Queue size: ${queue.size}`);
//=&gt; '3. Queue size: 1`

console.log(`4. Pending promises: ${queue.pending}`);
//=&gt; '4. Pending promises: 1'
</code></pre>
<pre><code>$ node example.js
1. Added ü¶Ñ
2. Added üê¥
3. Queue size: 1
4. Pending promises: 1
5. Resolved ü¶Ñ
6. Resolved üê¥
7. Queue is empty
8. Pending promises: 0
9. Added üêô
10. Pending promises: 1
11. Resolved üêô
12. All work is done
</code></pre>
<h2>Custom QueueClass</h2>
<p>For implementing more complex scheduling policies, you can provide a QueueClass in the options:</p>
<pre><code class="language-js">class QueueClass {
	constructor() {
		this._queue = [];
	}

	enqueue(run, options) {
		this._queue.push(run);
	}

	dequeue() {
		return this._queue.shift();
	}

	get size() {
		return this._queue.length;
	}

	filter(options) {
		return this._queue;
	}
}
</code></pre>
<p><code>p-queue</code> will call corresponding methods to put and get operations from this queue.</p>
<h2>Related</h2>
<ul>
<li><a href="https://github.com/sindresorhus/p-limit">p-limit</a> - Run multiple promise-returning &amp; async functions with limited concurrency</li>
<li><a href="https://github.com/sindresorhus/p-throttle">p-throttle</a> - Throttle promise-returning &amp; async functions</li>
<li><a href="https://github.com/sindresorhus/p-debounce">p-debounce</a> - Debounce promise-returning &amp; async functions</li>
<li><a href="https://github.com/sindresorhus/p-all">p-all</a> - Run promise-returning &amp; async functions concurrently with optional limited concurrency</li>
<li><a href="https://github.com/sindresorhus/promise-fun">More‚Ä¶</a></li>
</ul>
<hr>
<div align="center">
	<b>
		<a href="https://tidelift.com/subscription/pkg/npm-p-queue?utm_source=npm-p-queue&utm_medium=referral&utm_campaign=readme">Get professional support for this package with a Tidelift subscription</a>
	</b>
	<br>
	<sub>
		Tidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.
	</sub>
</div>
